/**
 * @packageDocumentation
 * @module api.functional.food.evaluate
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from "@nestia/fetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import type {
  IFoodEvaluationRequest,
  IFoodEvaluationResponse,
} from "../../../structures/food/IFoodCategory";

/**
 * 날씨 기반 음식 평가
 *
 * @param request - 평가 요청 정보
 * @description 사용자의 위치 정보를 받아 현재 날씨를 조회하고,
 *              날씨 조건에 따라 적합한 음식 카테고리를 평가하여 상위 3개를 추천합니다.
 *
 *              **평가 기준:**
 *              - 온도 분류: 더운 날씨(28°C↑), 온화한 날씨(18-27°C), 추운 날씨(17°C↓)
 *              - 습도 분류: 높은 습도(70%↑), 보통 습도(40-69%), 낮은 습도(39%↓)
 *              - 습도-제공온도 매트릭스를 활용한 점수 계산
 *
 *              **점수 매트릭스:**
 *              ```
 *              습도 \ 제공온도 | 차가운 | 따뜻한 | 뜨거운
 *              --------------|-------|-------|-------
 *              높은 습도      |   3   |   2   |   1
 *              보통 습도      |   2   |   3   |   2
 *              낮은 습도      |   1   |   2   |   3
 *              ```
 *
 *              **정렬 기준:**
 *              1차: 점수 내림차순, 2차: 카테고리 ID 오름차순
 * @summary 날씨 기반 음식 평가
 * @tag Food
 * @returns 날씨 기반 음식 평가 결과
 * @returns returns.location - 요청한 위치 정보
 * @returns returns.weather - 분석된 날씨 조건
 * @returns returns.topCategories - 상위 3개 추천 카테고리
 * @returns returns.metadata - 평가 메타데이터
 * @throws {400} 좌표가 대한민국 영역을 벗어난 경우
 * @throws {500} 날씨 조회 실패 등 내부 서버 오류
 * @example ```typescript
 *          // 서울 시청 기준 음식 추천
 *          const response = await fetch('/food/evaluate', {
 *          method: 'POST',
 *          headers: { 'Content-Type': 'application/json' },
 *          body: JSON.stringify({
 *          location: {
 *          lat: 37.5663,
 *          lng: 126.9779
 *          }
 *          })
 *          });
 *
 *          const result = await response.json();
 *          console.log(result.weather); // 현재 날씨 조건
 *          console.log(result.topCategories); // 상위 3개 추천 음식
 *          ```
 * @example ```typescript
 *          // 부산 기준 음식 추천
 *          const result = await evaluateFood({
 *          location: { lat: 35.1796, lng: 129.0756 }
 *          });
 *
 *          result.topCategories.forEach(category => {
 *          console.log(`${category.rank}위: ${category.nameKo} (점수: ${category.score})`);
 *          console.log(`이유: ${category.reason}`);
 *          });
 *          ```
 *
 * @controller FoodEvaluationController.evaluateFood
 * @path POST /food/evaluate
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function evaluateFood(
  connection: IConnection,
  request: evaluateFood.Body,
): Promise<evaluateFood.Output> {
  return true === connection.simulate
    ? evaluateFood.simulate(connection, request)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...evaluateFood.METADATA,
          template: evaluateFood.METADATA.path,
          path: evaluateFood.path(),
        },
        request,
      );
}
export namespace evaluateFood {
  export type Body = IFoodEvaluationRequest;
  export type Output = IFoodEvaluationResponse;

  export const METADATA = {
    method: "POST",
    path: "/food/evaluate",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 201,
  } as const;

  export const path = () => "/food/evaluate";
  export const random = (): IFoodEvaluationResponse =>
    typia.random<IFoodEvaluationResponse>();
  export const simulate = (connection: IConnection, request: Body): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(request));
    return random();
  };
}
