/**
 * @packageDocumentation
 * @module api.functional.weather.forecast_by_grid
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
//================================================================
import type { IConnection } from "@nestia/fetcher";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";

import type {
  IGrid,
  IWeatherForecastResponse,
} from "../../../structures/weather/IWeatherForecast";

/**
 * 격자 좌표 기반 날씨 예보 조회
 *
 * @param params - 격자 좌표 및 조회 옵션
 * @description 기상청 격자 좌표(nx, ny)를 직접 입력받아 해당 지역의 날씨 예보를 조회합니다.
 *              이미 격자 좌표를 알고 있는 경우 좌표 변환 과정을 생략할 수 있어 더 빠른 응답을 얻을 수 있습니다.
 *
 *              **사용 시나리오:**
 *              - 기상청 공식 격자 좌표표를 참조하여 정확한 좌표를 사용하는 경우
 *              - 반복적인 조회를 위해 미리 격자 좌표를 저장해둔 경우
 *              - 좌표 변환 과정을 생략하여 응답 속도를 최적화하려는 경우
 *
 *              **격자 좌표 범위:**
 *              - X 좌표: 1~149 (서쪽에서 동쪽으로)
 *              - Y 좌표: 1~253 (남쪽에서 북쪽으로)
 *
 *              **참고 자료:**
 *              - 기상청에서 제공하는 행정구역별 격자 좌표 Excel 파일 참조
 *              - Lambert Conformal Conic Projection 기반 좌표계 사용
 * @summary 격자 좌표로 날씨 예보 조회
 * @tag Weather
 * @returns 파싱된 날씨 예보 정보 (위경도는 추정값 포함)
 * @throws {400} 잘못된 격자 좌표 (범위 초과)
 * @throws {500} 기상청 API 호출 실패 등 내부 서버 오류
 * @example ```typescript
 *          // 서울(격자 60, 127)의 날씨 정보 조회
 *          const response = await fetch('/weather/forecast-by-grid', {
 *          method: 'POST',
 *          headers: { 'Content-Type': 'application/json' },
 *          body: JSON.stringify({
 *          x: 60,
 *          y: 127,
 *          numOfRows: 60
 *          })
 *          });
 *          ```
 *
 * @controller WeatherController.getWeatherForecastByGrid
 * @path POST /weather/forecast-by-grid
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function getWeatherForecastByGrid(
  connection: IConnection,
  params: getWeatherForecastByGrid.Body,
): Promise<getWeatherForecastByGrid.Output> {
  return true === connection.simulate
    ? getWeatherForecastByGrid.simulate(connection, params)
    : PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getWeatherForecastByGrid.METADATA,
          template: getWeatherForecastByGrid.METADATA.path,
          path: getWeatherForecastByGrid.path(),
        },
        params,
      );
}
export namespace getWeatherForecastByGrid {
  export type Body = IGrid & {
    baseDate?: string;
    baseTime?: string;
    numOfRows?: number;
  };
  export type Output = IWeatherForecastResponse;

  export const METADATA = {
    method: "POST",
    path: "/weather/forecast-by-grid",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
    status: 201,
  } as const;

  export const path = () => "/weather/forecast-by-grid";
  export const random = (): IWeatherForecastResponse =>
    typia.random<IWeatherForecastResponse>();
  export const simulate = (connection: IConnection, params: Body): Output => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: path(),
      contentType: "application/json",
    });
    assert.body(() => typia.assert(params));
    return random();
  };
}
